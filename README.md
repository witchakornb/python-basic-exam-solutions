# ชุดแบบฝึก Python พื้นฐาน (ง่ายไปยาก)

อธิบายแนวคิดแบบ **พื้นฐานที่สุด** เหมาะกับผู้เริ่มต้น ไม่ใช้เทคนิคขั้นสูงเกินจำเป็น

## การรันไฟล์

เปิดโฟลเดอร์นี้ใน VS Code หรือใช้ PowerShell:

```powershell
python problem1_fruit_basket.py
python problem2_meatballs.py
python problem3_shop_discount.py
python problem4_grade_report.py
python bonus1_vending_machine.py
python bonus2_pyramid_legend.py
```

---

## Problem 1: ตะกร้าผลไม้

เป้าหมาย: ฝึกการรับค่าหลายครั้ง, แปลงเป็นตัวเลขทศนิยม, รวมผล, จัดรูปแบบการแสดงผลให้อ่านง่าย

ทำไมออกแบบแบบนี้ (Why):

- ผู้เริ่มต้นยังไม่จำเป็นต้องใช้ loop ทันที ทำให้เห็นภาพว่า input 1 ตัว = ตัวแปร 1 ตัว
- ลด cognitive load: โฟกัสที่ชนิดข้อมูล (string -> float) และการ format ตัวเลข 2 ตำแหน่ง

ขั้นตอน (Step-by-step):

1. รับชื่อผลไม้ 4 ครั้ง (เก็บเป็น `item1` ... `item4`)
2. รับน้ำหนักแต่ละผลไม้ (ใช้ `float()` แปลงเป็นตัวเลข)
3. รวมด้วยการบวกตรง ๆ (อ่านง่าย: `total = w1 + w2 + w3 + w4`)
4. แสดงผลแต่ละบรรทัด ใช้การจัดตำแหน่งชื่อให้ชิดซ้าย น้ำหนักชิดขวา
5. สรุปผลรวมท้ายด้วยเส้นคั่น (ตามโจทย์กำหนด)

เหตุผลเลือก f-string + ความกว้างช่อง: เพื่อจัดคอลัมน์ให้ตรง ช่วยอ่านง่ายและจำ pattern การจัดรูปแบบ

แนวทางอื่น (Alternatives):

- ใช้ list + loop: วน 4 ครั้งเก็บใน list แล้วคำนวณ sum(list_of_weights)
- ใช้ `zip(items, weights)` วนแสดงผลรวบเดียว (หลังเรียน list แล้ว)
- ใช้ `format()` แทน f-string (เพื่อเทียบ style)

ข้อผิดพลาดที่พบบ่อย (Common mistakes):

- ลืมแปลงเป็น float → ไม่สามารถบวกได้
- พิมพ์ `%.2f` ผิดตำแหน่ง หรือ format ไม่ถูก → ตัวเลขแสดงไม่สวย
- ลืมเส้นคั่นตามโจทย์

ฝึกต่อยอด (Practice):

1. เพิ่มจำนวนรายการเป็น n โดยรับจำนวนก่อน แล้วใช้ loop
2. ตรวจว่า น้ำหนัก < 0 ให้แจ้งเตือนและให้ใส่ใหม่
3. เพิ่มคอลัมน์ "เปอร์เซ็นต์น้ำหนักต่อรวม" (weight / total * 100)

สรุป: โจทย์นี้สอนโครงสร้างข้อมูลพื้นฐานและการจัดรูปแบบสิ่งที่ผู้ใช้ป้อนอย่างมีระบบ

## Problem 2: ลูกชิ้นเนื้อล้วนๆ

เป้าหมาย: ฝึกคิดคณิตแบบง่าย + การปัดขึ้น (ceiling) โดยไม่ใช้ฟังก์ชันสำเร็จ (เพื่อเข้าใจตรรกะ)

โจทย์สรุป: ต้องใช้ลูกชิ้นทั้งหมดกี่ลูก -> `needed = m * k`. 1 ถุงมี `n` ลูก ต้องใช้กี่ถุง (ปัดขึ้น)

ขั้นตอน:

1. รับจำนวนไม้ (m)
2. รับจำนวนลูกชิ้นต่อไม้ (k)
3. รับจำนวนลูกชิ้นในหนึ่งถุง (n)
4. คำนวณลูกชิ้นที่ต้องใช้ทั้งหมด = m * k
5. ถ้า `needed % n == 0` → ใช้ `needed // n` ถุง
6. ถ้าไม่ลงตัว → ใช้ `(needed // n) + 1`
7. แสดงผลเป็นจำนวนเต็ม

ทำไมใช้ `%` (modulo): ช่วยตรวจว่ามีเศษเหลือไหม ถ้ามีต้องเพิ่มอีก 1 ถุงเสมอ

แนวทางอื่น:

- ใช้สูตรทางเดียว: `(needed + n - 1) // n` (เทคนิคปัดขึ้นด้วย integer)
- ใช้ `import math` แล้ว `math.ceil(needed / n)` (หลังเรียน module)
- เขียน while ลบทีละ n (**ช้าแต่สอน loop**)

Common mistakes:

- ลืมแปลง input เป็น int → คูณแล้วกลายเป็น string ซ้อนกัน
- สลับตัวแปร (เช่น ใช้ m + k แทน m * k)
- ลืมกรณี needed น้อยกว่า n (ควรได้ 1 ถุง)

ฝึกต่อยอด:

1. รองรับหลายคำสั่งของลูกค้าต่อวัน (สะสมรวม)
2. เพิ่มราคาต่อถุง คำนวณต้นทุนรวม
3. เพิ่มเงื่อนไข: สินค้าขายเป็นแพ็ก 5 ถุง ได้ส่วนลด

สรุป: โจทย์นี้เน้นการคิดตรรกะปัดขึ้นและใช้ตัวดำเนินการ `%` + `//` อย่างถูกต้อง

## Problem 3: ระบบคำนวณส่วนลด

เป้าหมาย: ฝึกการซ้อนเงื่อนไข (nested / chained if) และการวิเคราะห์ช่วง (range) ของยอดซื้อ

ขั้นตอนหลัก:

1. รับสถานะสมาชิก (y/n)
2. รับยอดซื้อ (float)
3. ถ้าเป็นสมาชิก:

	- >= 1000 → 20%
	- 500–999 → 10%
	- น้อยกว่านั้น → 0

4. ถ้าไม่เป็นสมาชิก:

	- >= 1000 → 5%
	- อื่น ๆ → 0
5. คำนวณ discount, คำนวณ final = amount - discount
6. แสดงผลด้วยทศนิยม 2 ตำแหน่ง

เหตุผลรูปแบบนี้: แยก "เป็นสมาชิกหรือไม่" ก่อน เพื่อลดการเขียนเงื่อนไขซ้ำซ้อนหลายอัน (อ่านง่าย)

แนวทางอื่น:

- ใช้โครงสร้าง if เดียวแต่รวมหลายเงื่อนไขด้วย and (อ่านยากขึ้นสำหรับผู้เริ่มต้น)
- ใช้ dictionary แม็ปช่วง (หลังเรียนฟังก์ชัน / โครงสร้างข้อมูลเพิ่ม)
- สร้างฟังก์ชัน `get_discount_rate(is_member, amount)` คืนเปอร์เซ็นต์ (แยก logic ออกจาก I/O)

Common mistakes:

- ลืมใช้ `>= 500` แต่ไปใช้ `> 500` ทำให้ 500 ไม่เข้าเงื่อนไข
- ตรวจช่วงผิดลำดับ เช่น เช็ค >= 500 ก่อน >= 1000 (ทำให้ 1000 ได้แค่ 10%)
- ลืมแปลง input เป็น float → เกิดการต่อ string

ฝึกต่อยอด:

1. เพิ่มคูปอง (เช่น ใส่โค้ดลดเพิ่ม 5%)
2. แยกราคา VAT ก่อน/หลังส่วนลด
3. รองรับหลายรายการย่อย แล้ว sum ก่อนคิดส่วนลด
4. เก็บประวัติการคำนวณใน list

สรุป: โจทย์นี้สอนการจัดลำดับเงื่อนไขให้ถูกเพื่อหลีกเลี่ยงผลลัพธ์ผิดพลาด

## Problem 4: รายงานเกรด

เป้าหมาย: ฝึก loop รับข้อมูลซ้ำจนผู้ใช้หยุด, เก็บข้อมูลคู่ขนาน (parallel lists), คำนวณค่าเฉลี่ย, หา max/min ด้วยมือ

เหตุผลยังไม่ใช้ max()/min(): เพื่อให้เข้าใจ “การไล่เทียบ” (comparison) ทีละตัว เรียนรู้ pattern พื้นฐาน

ขั้นตอน:

1. เริ่ม count = 1 ใช้ช่วยพิมพ์หมายเลขนักศึกษา
2. while True:

	- รับชื่อ → append
	- รับเกรด (float) → append
	- ถามต่อไหม (y/n) → ถ้า n: break
3. คำนวณ sum ด้วย loop (ไม่ใช้ sum())
4. average = total / จำนวนคน
5. หา max/min:

	- ตั้งค่าตั้งต้นเป็นสมาชิกตัวแรก
	- วนตั้งแต่ index 1 เทียบแล้วอัพเดต
6. แสดงผล

แนวทางอื่น:

- ใช้ list ของ tuple: `[('Ake', 4.0), ...]`
- ใช้ dict: `{name: grade}` (แต่ตอนหา max/min ต้องแตก key/value)
- ใช้ฟังก์ชันในตัว: `max_index = grades.index(max(grades))`
- สร้างฟังก์ชัน `report(names, grades)` คืน dict สรุป

Common mistakes:

- ลืมกรณีไม่มีข้อมูล (ควรตรวจ len == 0)
- ไม่แปลงเป็น float → เกรดกลายเป็น string เทียบผิด
- พิมพ์ Continue? (y/n) แล้วกรอกค่าอื่นที่ไม่ใช่ y หรือ n

ฝึกต่อยอด:

1. เพิ่มการตรวจสอบเกรดให้อยู่ในช่วง 0.0–4.0
2. เพิ่มแสดงชื่อทุกคน + เกรด เรียงจากมากไปน้อย
3. คำนวณ Median / Highest 3 / Lowest 3
4. บันทึกไฟล์ (เขียนเป็น text)

สรุป: โจทย์นี้ปูพื้นแนวทางการเก็บข้อมูลหลายค่า แล้วทำสถิติเบื้องต้น

## Bonus 1: เครื่องกดเครื่องดื่ม

เป้าหมาย: ฝึก if/elif หลายทาง + เงื่อนไข out of stock + การคำนวณราคาจากจำนวน

แนวคิดหลัก: แยกสินค้าเป็นตัวแปร (ง่ายชัด แต่ซ้ำ) → ตรวจหมายเลข → ตรวจสต็อก → ขายหรือปฏิเสธ

เหตุผลไม่ใช้โครงสร้างข้อมูล: ให้ผู้เริ่มต้นเห็น “โค้ดซ้ำ” ก่อน แล้วค่อย appreciate การยุบด้วย list/dict ในอนาคต

แนวทางอื่น (เมื่อพร้อม):

- products = {"items": [{"name":"Coffee","price":2.5,"qty":10}, ...]} แล้ววนแสดงอัตโนมัติ
- ใช้ dict: `{1:{...},2:{...}}` เพื่อเลือกด้วยเลข
- ทำ loop ซื้อหลายรอบจนกด q ออก พร้อมตัด stock

ข้อผิดพลาดที่พบบ่อย:

- ไม่ตรวจ qty > stock
- ลืมกรอง choice ไม่อยู่ใน (1,2,3)
- ใช้ `and` แทน `or` ในเงื่อนไข stock หมด (ทำให้ไม่จับกรณีสั่งเกิน)

ต่อยอด:

1. ระบบเงินหยอด + เงินทอน
2. เพิ่มประเภทสินค้าใหม่ง่ายขึ้นด้วยการเปลี่ยนโครงสร้างข้อมูล
3. บันทึก log การขายแต่ละครั้ง

สรุป: เป็นสะพานไปสู่การใช้โครงสร้างข้อมูลแบบ dynamic ในเวอร์ชันถัดไป

## Bonus 2: พีระมิดตำนาน

เป้าหมาย: ผสานคณิต (ผลบวก 1..N), เงื่อนไขคู่/คี่, การสร้าง pattern ด้วยลูปซ้อน และการควบคุมทิศทาง

การตัดสินใจสำคัญ: ใช้ลูปสะสม total (ให้เข้าใจ) ก่อนเผยสูตร `N*(N+1)//2`

ขั้นตอนย่อ:

1. รับ N
2. total = 1+2+...+N (ผ่าน loop)
3. ตรวจคู่คี่ (`total % 2`)
4. เลือกทิศทาง: ขึ้น (1→N) หรือ ลง (N→1)
5. ลูปแถวซ้อนลูปสร้างสตริงตัวเลขซ้ำ (ระวังช่องว่างหัวท้าย)

Alternative:

- ใช้สูตร total เลย เพื่อลด O(N) → เหลือ O(1) ในส่วนคำนวณ
- ใช้ `' '.join([str(row)] * row)` แทน loop ชั้นใน (เมื่อเริ่มคล่อง)

ความซับซ้อน (Complexity): O(N^2) ในการพิมพ์ pattern (หลีกเลี่ยงไม่ได้ถ้าต้องพิมพ์ทั้งหมด)

ข้อผิดพลาดที่พบบ่อย:

- ลืม `range(N, 0, -1)` (เผลอใช้ `range(N, 1, -1)` ทำให้ไม่ถึง 1)
- ต่อสตริงโดยมี space เกินหัว / ท้าย (ไม่ผิดแต่ไม่สวย)
- สลับเงื่อนไขคู่/คี่

ต่อยอด:

1. เปลี่ยนเป็นพิมพ์สัญลักษณ์ เช่น * หรือ #
2. สร้างพีระมิดเวอร์ชันตรงกลาง (centered)
3. พิมพ์แบบเลขเรียง (1 / 2 2 / 3 3 3 → เปลี่ยนเป็น 1 / 1 2 / 1 2 3)
4. เพิ่มตรวจความถูกต้องของ N (ถ้าเกิน 50 แจ้งเตือน)

สรุป: โจทย์นี้สอนแนว pattern generation ที่จะใช้บ่อยในงานฝึก algorithm พื้นฐาน

---

## ข้อเสนอแนะการฝึกต่อ

1. ลองปรับ Problem 1 ให้ใช้ลูปและ list
2. เปลี่ยน Problem 2 ให้รองรับการสั่งหลายครั้งรวมกัน
3. ทำ Problem 3 ให้รองรับรหัสคูปองเพิ่ม
4. เก็บข้อมูลใน Problem 4 เป็น dict หรือ list ของ tuple
5. Vending Machine ใช้ list/dict แล้ววนอัตโนมัติ
6. พีระมิด: ลองใช้การ join แทนต่อสตริงด้วย if

ฝึกบ่อย ๆ จะเข้าใจ pattern ของ input -> process -> output ดีขึ้น 🙂
